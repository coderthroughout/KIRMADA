{"noir_version":"1.0.0-beta.6+e796dfd67726cbc28eb9991782533b211025928d","hash":"10923234343379464271","abi":{"parameters":[{"name":"dataset_hash","type":{"kind":"field"},"visibility":"private"},{"name":"num_samples","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"dataset_size","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"feature_dim","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"num_classes","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"format_version","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"public"},"error_types":{}},"bytecode":"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w84aXfRMtk2rGR3eFE47Wm8K3ASbCacdWsPN4LSji+JWEYcpbkSh26RadjHe3BLaQWp8C0tpZ2XcJ9lieybbll5h3ipIO1saaGerGGhnZSDtbAkU5VbVPMlFb0RkzFsL7wSpOG7B0PVvI5x2KC/bWBA3l8a3AWp8W+EaD2tSVLShkU3KdpbSzkrAP5Hi93f7akaHt6/G291BOKFQ3Dv4Og+QXRaqoIKyXbXsorejJVSB1OVOzIUekZOdGDQeZ0Fdkamg7lzN6PDODAV1F+EFleLeJaaCqqINTRtjl2qeDYeKO85N1gH4t0P8/u5azejwrgwn4q7Air6b8A1La7gbwybYTfhrtLRJd2PAnx2B+d5d+MsFpJ3dmYp9YaD39u7A/OwhHPHDiEFFGxpJDHsK1zjleE+GRg6pQ/KNGoUunj36dwfvT9jT9Yq+65V81yv7rjv6rjv5rjv7rlfxXa/qu17Nd72677qL77qr73oN3/Wavuu1fNdr+67X8V13811391338F339F338l339l338V339V33810r37X2XSd81/W+66R3vZf7f/Z25z7u3Ned+7lzf3ce4M4D3XmQOxvdmXVnzp15dza5s9mdB7vzEHce6s7D3Hm4O49w55HuPMqdR7vzGHce687j3Hm8O09w54nuPMmdJ1f/rQXa84W3UAqaQOp3bdKDzz7ILt/7UyrB+t5XiW+du3jXp7i5ONWdp7nzdHee4c4z3XmWO8925znuPNed57nzfHde4M4L3XmROy925yXuvNSdl7nzcncOdOcgdw525xB3DnXnMHcOd+cId4505xXuHOXOKwuiLLzHRs4E751quHea4d7phntnGO6dabh3luHe2YZ75xjunWu4d57h3vmGexcY7l1ouHeR4d7FhnuXGO5darh3meHe5YZ7Aw33BhnuDTbcG2K4N9Rwb5jh3nDDvRGGeyMN964w3BtluHdl9b/v56ILDxUdKj5dAnajHqK0P6LaKrw/fCrIFsV7GsTW32t3enRbCW+99BlRbSX/WXt9ZjRbypdHfVYUW4kiTeiz229LBfSlz2mnrYbmFlrV57bPVtqge31ee2yljXtIn992W6mQ/agvaKutVOje1he2zVZiEXVCX9QWW6lF1hx9cett5RZTv/QlrbWVWmwt1Je2zpZqRV3Vl7XGlmpVjdaXL95W/1bWez1wcbaS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","debug_symbols":"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ecF5wXnBecF5sT4v1ucF5wXnBefF+rxYnxecF5wXnBecF5wXnBecF+vzYn1ecF5wXnBerM+L9XnBecF5wXnBecF5wXnBebE+L9bnBecF5wXnxfq8WJ8XnBecF5wXnBecF5wXnBfr82J9XnBecF5wXqzPi/V5wXnBecF5wXnBecF5wXmxPi/W5wXnBecF58X6vFifF5wXnBecF5wXnBecF5wX6/NifV5wXnBecP70w71+ln24gvOC84LzgvOC84LzgvOnH+6lwT5cwXnBecF5MW8v5u0F5wXnDecN5w3nDecN508/3FOj2YdrOG84bzhv5u3NPlzDecN5w3nDecN5w3nD+dMP99JgH67hvOG84byZtzf7cA3nDecN5w3nDecN5w3nTz/cS4N9uIbzhvOG82be3uzDNZw3nDecN5w3nDecN5w//XAvDfbhGs4bzhvOm3l7sw/XcN5w3nDecN5w3nDecP70w7002IdrOG84bzhv5u3NPlzDecN5w3nDecN5w3nD+dMP99JgH67hvOG84byZtzf7cA3nDecN5w3nDecN5w3nvdDYPA84bzhvOG/m7Q3nTT1v6nnDeTNvH52fx7A+HzgfOB84H+r50w/33Al8+uFq//u7D//7/S8/fv+njz/848Mf/vX2x7/+86c///rjzz/df/z1//9df/OnX378+PHHv/3x77/8/Ocf/vLPX37448ef//z8u3//z7//Dw==","file_map":{"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"50":{"source":"use dep::std::hash::hash_to_field;\r\n\r\n// Data integrity proof circuit for Aztec Protocol\r\n// Proves that the training dataset is valid and properly formatted\r\n\r\n// Input structure for data integrity proof\r\nstruct DataIntegrityInput {\r\n    // Dataset hash\r\n    dataset_hash: Field,\r\n    // Number of samples in dataset\r\n    num_samples: u32,\r\n    // Dataset size in bytes\r\n    dataset_size: u32,\r\n    // Feature dimension\r\n    feature_dim: u32,\r\n    // Number of classes\r\n    num_classes: u32,\r\n    // Dataset format version\r\n    format_version: u32,\r\n}\r\n\r\n\r\n\r\n// Main data integrity proof circuit\r\nfn main(\r\n    dataset_hash: Field,\r\n    num_samples: u32,\r\n    dataset_size: u32,\r\n    feature_dim: u32,\r\n    num_classes: u32,\r\n    format_version: u32,\r\n) -> pub [Field; 3] {\r\n    // Create data integrity input\r\n    let data_input = DataIntegrityInput {\r\n        dataset_hash,\r\n        num_samples,\r\n        dataset_size,\r\n        feature_dim,\r\n        num_classes,\r\n        format_version,\r\n    };\r\n\r\n    // Verify data integrity\r\n    let data_valid = verify_data_integrity(data_input);\r\n    \r\n    // Calculate dataset fingerprint\r\n    let dataset_fingerprint = calculate_dataset_fingerprint(data_input);\r\n    \r\n    // Generate proof hash\r\n    let proof_hash = hash_data_integrity_proof(data_input, data_valid, dataset_fingerprint);\r\n    \r\n    [proof_hash, data_valid.into(), dataset_fingerprint]\r\n}\r\n\r\n// Verify that the dataset meets integrity requirements\r\nfn verify_data_integrity(input: DataIntegrityInput) -> bool {\r\n    // Check that dataset hash is valid (non-zero)\r\n    let hash_valid = input.dataset_hash != 0;\r\n    \r\n    // Check that number of samples is reasonable\r\n    let samples_valid = input.num_samples > 0 & input.num_samples <= 1000000;\r\n    \r\n    // Check that dataset size is reasonable\r\n    let size_valid = input.dataset_size > 0 & input.dataset_size <= 1000000000;\r\n    \r\n    // Check that feature dimension is reasonable\r\n    let feature_valid = input.feature_dim > 0 & input.feature_dim <= 10000;\r\n    \r\n    // Check that number of classes is reasonable\r\n    let classes_valid = input.num_classes > 0 & input.num_classes <= 1000;\r\n    \r\n    // Check that format version is supported\r\n    let format_valid = input.format_version == 1;\r\n    \r\n    // All conditions must be met\r\n    hash_valid & samples_valid & size_valid & feature_valid & classes_valid & format_valid\r\n}\r\n\r\n// Calculate dataset fingerprint\r\nfn calculate_dataset_fingerprint(input: DataIntegrityInput) -> Field {\r\n    let fingerprint_data = [\r\n        input.dataset_hash,\r\n        input.num_samples as Field,\r\n        input.dataset_size as Field,\r\n        input.feature_dim as Field,\r\n        input.num_classes as Field,\r\n        input.format_version as Field\r\n    ];\r\n    \r\n    hash_to_field(fingerprint_data)\r\n}\r\n\r\n// Hash the complete data integrity proof\r\nfn hash_data_integrity_proof(input: DataIntegrityInput, valid: bool, fingerprint: Field) -> Field {\r\n    let valid_field: Field = if valid { 1 } else { 0 };\r\n    \r\n    let proof_data = [\r\n        input.dataset_hash,\r\n        input.num_samples as Field,\r\n        input.dataset_size as Field,\r\n        input.feature_dim as Field,\r\n        input.num_classes as Field,\r\n        input.format_version as Field,\r\n        valid_field,\r\n        fingerprint\r\n    ];\r\n    \r\n    hash_to_field(proof_data)\r\n} ","path":"/mnt/c/Users/anura/OneDrive/Desktop/aztec/circuits/data_integrity/src/main.nr"}},"names":["main"],"brillig_names":["directive_invert","directive_integer_quotient","directive_to_radix"]}